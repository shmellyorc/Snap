namespace Snap.Assets.LDTKImporter;

/// <summary>
/// Defines the various types of layers used in a map or LDTK level.
/// Determines how a layer should be interpreted and which data it exposes.
/// </summary>
public enum MapLayerType
{
	/// <summary>
	/// Placeholder value representing an undefined or unsupported layer type.
	/// </summary>
	None,

	/// <summary>
	/// A logic-driven integer grid layer, typically used for collisions, flags, or game logic.
	/// Int values are mapped to behaviors in code.
	/// </summary>
	IntGrid,

	/// <summary>
	/// A layer that contains placed entity instances such as triggers, NPCs, or props.
	/// Entity metadata is parsed from embedded fields.
	/// </summary>
	Entities,

	/// <summary>
	/// A standard tilemap layer composed of individually placed tiles from a tileset atlas.
	/// Each tile has its own position and optional flip flags.
	/// </summary>
	Tiles,

	/// <summary>
	/// A procedurally rendered tilemap layer generated by LDTKâ€™s auto-layer rules.
	/// These tiles are often decorative or generated based on adjacent tile rules.
	/// </summary>
	AutoLayer

}

/// <summary>
/// Represents a single layer within a level.
/// Can contain int grid data, placed entities, or tiles depending on the layer type.
/// </summary>
public class MapLayer
{
	/// <summary>
	/// The display name of the layer as defined in the editor.
	/// </summary>
	public string Name { get; }

	/// <summary>
	/// The type of the layer, which determines how its data is interpreted.
	/// </summary>
	public MapLayerType Type { get; }

	/// <summary>
	/// The size of the layer grid in columns and rows.
	/// </summary>
	public Vect2 GridSize { get; }

	/// <summary>
	/// The size of an individual tile in pixels.
	/// </summary>
	public int TileSize { get; }

	/// <summary>
	/// The layer's opacity value ranging from 0.0 (fully transparent) to 1.0 (opaque).
	/// </summary>
	public float Opacity { get; }

	/// <summary>
	/// The total world-space offset of this layer, relative to the level origin.
	/// </summary>
	public Vect2 TotalOffset { get; }

	/// <summary>
	/// The unique identifier of the tileset used by this layer, if applicable.
	/// Returns -1 if no tileset is assigned.
	/// </summary>
	public int TilesetId { get; }

	/// <summary>
	/// The relative path to the tileset image used by this layer, if any.
	/// </summary>
	public string TilesetPath { get; }

	/// <summary>
	/// The unique instance identifier of this layer.
	/// </summary>
	public string Id { get; }

	/// <summary>
	/// The numeric ID of the level this layer belongs to.
	/// </summary>
	public int LevelId { get; }

	/// <summary>
	/// The per-layer visual offset in pixels, relative to the level position.
	/// </summary>
	public Vect2 Offset { get; }

	/// <summary>
	/// Indicates whether the layer is currently marked as visible.
	/// </summary>
	public bool Visible { get; }

	/// <summary>
	/// A list of typed instances contained in this layer.
	/// These could be entity instances, tile instances, or int grid entries depending on layer type.
	/// </summary>
	public List<MapInstance> Instances { get; }

	/// <summary>
	/// Returns the list of instances in this layer, filtered by the specified type.
	/// </summary>
	/// <typeparam name="T">The type of <see cref="MapInstance"/> to extract.</typeparam>
	/// <returns>A list of instances cast to the desired type.</returns>
	public List<T> InstanceAs<T>() where T : MapInstance => Instances.OfType<T>().ToList();

	internal MapLayer(string name, MapLayerType type, Vect2 gridSize, int tileSize, float opacity,
		Vect2 totalOffset, int tilesetId, string tilesetPath, string id, int levelId, Vect2 offset,
		bool visible, List<MapInstance> instances)
	{
		Name = name;
		Type = type;
		GridSize = gridSize;
		TileSize = tileSize;
		Opacity = opacity;
		TotalOffset = totalOffset;
		TilesetId = tilesetId;
		TilesetPath = tilesetPath;
		Id = id;
		LevelId = levelId;
		Offset = offset;
		Visible = visible;
		Instances = instances;
	}

	internal static List<MapLayer> Process(JsonElement e)
	{
		var result = new List<MapLayer>(e.GetArrayLength());

		foreach (var t in e.EnumerateArray())
		{
			var name = t.GetPropertyOrDefault("__identifier", string.Empty);
			var type = Enum.Parse<MapLayerType>(t.GetPropertyOrDefault("__type", "None"), true);
			var cX = t.GetPropertyOrDefault<int>("__cWid");
			var cY = t.GetPropertyOrDefault<int>("__cHei");
			var tileSize = t.GetPropertyOrDefault<int>("__gridSize");
			var opacity = t.GetPropertyOrDefault<float>("__opacity");
			var totalOffsetX = t.GetPropertyOrDefault<int>("__pxTotalOffsetX");
			var totalOffsetY = t.GetPropertyOrDefault<int>("__pxTotalOffsetY");
			var tilesetId = t.GetPropertyOrDefault("__tilesetDefUid", -1);
			var tilesetPath = t.GetPropertyOrDefault("__tilesetRelPath", string.Empty);
			var id = t.GetPropertyOrDefault("iid", string.Empty);
			var levelId = t.GetPropertyOrDefault<int>("levelId");
			var offsetX = t.GetPropertyOrDefault<int>("pxOffsetX");
			var offsetY = t.GetPropertyOrDefault<int>("pxOffsetY");
			var visible = t.GetPropertyOrDefault<bool>("visible");
			var gridSize = new Vect2(cX, cY);

			List<MapInstance> instResult = type switch
			{
				MapLayerType.IntGrid => MapIntGridInstance.Process(t.GetProperty("intGridCsv"), gridSize),
				MapLayerType.Entities => MapEntityInstance.Process(t.GetProperty("entityInstances")),
				MapLayerType.Tiles => MapTileInstance.Process(t.GetProperty("gridTiles"), tileSize),
				MapLayerType.AutoLayer => MapTileInstance.Process(t.GetProperty("autoLayerTiles"), tileSize),
				_ => throw new ArgumentException($"Unable to find Map layer type, it is '{type}'.")
			};

			result.Add(
				new MapLayer(name, type, gridSize, tileSize, opacity, new(totalOffsetX, totalOffsetY),
					tilesetId, tilesetPath, id, levelId, new(offsetX, offsetY), visible, instResult)
			);
		}

		return result;
	}
}
